# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T11:23:28+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBearer,
    UnsuportedSecurityStub,
)
from fastapi import Query
from pydantic import conint, constr

from models import (
    AddOrDeleteRulesRequest,
    AddOrDeleteRulesResponse,
    BlockUserMutationResponse,
    BlockUserRequest,
    BookmarkAddRequest,
    BookmarkMutationResponse,
    ComplianceJobFields,
    ComplianceJobFields1,
    CreateComplianceJobRequest,
    CreateComplianceJobResponse,
    CreateDmConversationRequest,
    CreateDmEventResponse,
    CreateMessageRequest,
    DmConversationId,
    DmEventFields,
    DmEventFields1,
    DmEventFields2,
    Error,
    EventTypes,
    EventTypes1,
    EventTypes2,
    Exclude,
    Exclude1,
    Exclude2,
    Expansions1,
    Expansions2,
    Expansions3,
    Expansions4,
    Expansions5,
    Expansions6,
    Expansions7,
    Expansions8,
    Expansions9,
    Expansions10,
    Expansions11,
    Expansions12,
    Expansions13,
    Expansions14,
    Expansions15,
    Expansions16,
    Expansions17,
    Expansions18,
    Expansions19,
    Expansions20,
    Expansions21,
    Expansions22,
    Expansions23,
    Expansions24,
    Expansions25,
    Expansions26,
    Expansions27,
    Expansions28,
    Expansions29,
    Expansions30,
    Expansions31,
    Expansions32,
    Expansions33,
    Expansions34,
    Expansions35,
    Expansions36,
    Expansions37,
    Expansions38,
    Expansions39,
    Expansions40,
    Expansions41,
    Expansions42,
    FilteredStreamingTweetResponse,
    Get2ComplianceJobsIdResponse,
    Get2ComplianceJobsResponse,
    Get2DmConversationsIdDmEventsResponse,
    Get2DmConversationsWithParticipantIdDmEventsResponse,
    Get2DmEventsResponse,
    Get2ListsIdFollowersResponse,
    Get2ListsIdMembersResponse,
    Get2ListsIdResponse,
    Get2ListsIdTweetsResponse,
    Get2SpacesByCreatorIdsResponse,
    Get2SpacesIdBuyersResponse,
    Get2SpacesIdResponse,
    Get2SpacesIdTweetsResponse,
    Get2SpacesResponse,
    Get2SpacesSearchResponse,
    Get2TweetsCountsAllResponse,
    Get2TweetsCountsRecentResponse,
    Get2TweetsIdLikingUsersResponse,
    Get2TweetsIdQuoteTweetsResponse,
    Get2TweetsIdResponse,
    Get2TweetsIdRetweetedByResponse,
    Get2TweetsResponse,
    Get2TweetsSample10StreamResponse,
    Get2TweetsSearchAllResponse,
    Get2TweetsSearchRecentResponse,
    Get2UsersByResponse,
    Get2UsersByUsernameUsernameResponse,
    Get2UsersIdBlockingResponse,
    Get2UsersIdBookmarksResponse,
    Get2UsersIdFollowedListsResponse,
    Get2UsersIdFollowersResponse,
    Get2UsersIdFollowingResponse,
    Get2UsersIdLikedTweetsResponse,
    Get2UsersIdListMembershipsResponse,
    Get2UsersIdMentionsResponse,
    Get2UsersIdMutingResponse,
    Get2UsersIdOwnedListsResponse,
    Get2UsersIdPinnedListsResponse,
    Get2UsersIdResponse,
    Get2UsersIdTimelinesReverseChronologicalResponse,
    Get2UsersIdTweetsResponse,
    Get2UsersMeResponse,
    Get2UsersResponse,
    Granularity,
    Ids,
    Ids1,
    Ids2,
    Ids3,
    JobId,
    ListAddUserRequest,
    ListCreateRequest,
    ListCreateResponse,
    ListDeleteResponse,
    ListFields,
    ListFields1,
    ListFields2,
    ListFields3,
    ListFields4,
    ListFollowedRequest,
    ListFollowedResponse,
    ListId,
    ListMutateResponse,
    ListPinnedRequest,
    ListPinnedResponse,
    ListUnpinResponse,
    ListUpdateRequest,
    ListUpdateResponse,
    MediaFields,
    MediaFields1,
    MediaFields2,
    MediaFields3,
    MediaFields4,
    MediaFields5,
    MediaFields6,
    MediaFields7,
    MediaFields8,
    MediaFields9,
    MediaFields10,
    MediaFields11,
    MediaFields12,
    MediaFields13,
    MediaFields14,
    MediaFields15,
    MediaFields16,
    MediaFields17,
    MediaFields18,
    MuteUserMutationResponse,
    MuteUserRequest,
    PaginationToken32,
    PaginationToken36,
    PaginationTokenLong,
    PlaceFields,
    PlaceFields1,
    PlaceFields2,
    PlaceFields3,
    PlaceFields4,
    PlaceFields5,
    PlaceFields6,
    PlaceFields7,
    PlaceFields8,
    PlaceFields9,
    PlaceFields10,
    PlaceFields11,
    PlaceFields12,
    PlaceFields13,
    PlaceFields14,
    PlaceFields15,
    PollFields,
    PollFields1,
    PollFields2,
    PollFields3,
    PollFields4,
    PollFields5,
    PollFields6,
    PollFields7,
    PollFields8,
    PollFields9,
    PollFields10,
    PollFields11,
    PollFields12,
    PollFields13,
    PollFields14,
    PollFields15,
    RulesLookupResponse,
    SearchCountFields,
    SearchCountFields1,
    SortOrder,
    SpaceFields,
    SpaceFields1,
    SpaceFields2,
    SpaceFields3,
    State1,
    Status,
    StreamingTweetResponse,
    TopicFields,
    TopicFields1,
    TopicFields2,
    TopicFields3,
    TweetComplianceStreamResponse,
    TweetCreateRequest,
    TweetCreateResponse,
    TweetDeleteResponse,
    TweetFields,
    TweetFields1,
    TweetFields2,
    TweetFields3,
    TweetFields4,
    TweetFields5,
    TweetFields6,
    TweetFields7,
    TweetFields8,
    TweetFields9,
    TweetFields10,
    TweetFields11,
    TweetFields12,
    TweetFields13,
    TweetFields14,
    TweetFields15,
    TweetFields16,
    TweetFields17,
    TweetFields18,
    TweetFields19,
    TweetFields20,
    TweetFields21,
    TweetFields22,
    TweetFields23,
    TweetFields24,
    TweetFields25,
    TweetFields26,
    TweetFields27,
    TweetFields28,
    TweetFields29,
    TweetFields30,
    TweetFields31,
    TweetFields32,
    TweetHideRequest,
    TweetHideResponse,
    TweetId,
    TweetLabelStreamResponse,
    Type4,
    UserComplianceStreamResponse,
    UserFields,
    UserFields1,
    UserFields2,
    UserFields3,
    UserFields4,
    UserFields5,
    UserFields6,
    UserFields7,
    UserFields8,
    UserFields9,
    UserFields10,
    UserFields11,
    UserFields12,
    UserFields13,
    UserFields14,
    UserFields15,
    UserFields16,
    UserFields17,
    UserFields18,
    UserFields19,
    UserFields20,
    UserFields21,
    UserFields22,
    UserFields23,
    UserFields24,
    UserFields25,
    UserFields26,
    UserFields27,
    UserFields28,
    UserFields29,
    UserFields30,
    UserFields31,
    UserFields32,
    UserFields33,
    UserFields34,
    UserFields35,
    UserFields36,
    UserFields37,
    UserFields38,
    UserFields39,
    UserFields40,
    UserFields41,
    UserId,
    UserIdMatchesAuthenticatedUser,
    UserIds,
    Usernames,
    UsersFollowingCreateRequest,
    UsersFollowingCreateResponse,
    UsersFollowingDeleteResponse,
    UsersLikesCreateRequest,
    UsersLikesCreateResponse,
    UsersLikesDeleteResponse,
    UsersRetweetsCreateRequest,
    UsersRetweetsCreateResponse,
    UsersRetweetsDeleteResponse,
)
from models.field_2Openapi import JsonGetResponse

app = MCPProxy(
    contact={
        'name': 'Twitter Developers',
        'url': 'https://developer.twitter.com/',
        'x-twitter': 'twitter',
    },
    description='Twitter API v2 available endpoints',
    license={
        'name': 'Twitter Developer Agreement and Policy',
        'url': 'https://developer.twitter.com/en/developer-terms/agreement-and-policy.html',
    },
    termsOfService='https://developer.twitter.com/en/developer-terms/agreement-and-policy.html',
    title='Twitter API v2',
    version='2.61',
    servers=[{'description': 'Twitter API', 'url': 'https://api.twitter.com'}],
)


@app.get(
    '/2/compliance/jobs',
    description=""" Returns recent Compliance Jobs for a given job type and optional job status """,
    tags=['compliance_job_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_batch_compliance_jobs(
    type: Type4,
    status: Optional[Status] = None,
    compliance_job_fields: Optional[ComplianceJobFields] = Query(
        None, alias='compliance_job.fields'
    ),
):
    """
    List Compliance Jobs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/compliance/jobs',
    description=""" Creates a compliance for the given job type """,
    tags=['compliance_job_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_batch_compliance_job(body: CreateComplianceJobRequest):
    """
    Create compliance job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/compliance/jobs/{id}',
    description=""" Returns a single Compliance Job by ID """,
    tags=['compliance_job_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_batch_compliance_job(
    id: JobId,
    compliance_job_fields: Optional[ComplianceJobFields1] = Query(
        None, alias='compliance_job.fields'
    ),
):
    """
    Get Compliance Job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/dm_conversations',
    description=""" Creates a new DM Conversation. """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dm_conversation_id_create(body: CreateDmConversationRequest = None):
    """
    Create a new DM Conversation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/dm_conversations/with/{participant_id}/dm_events',
    description=""" Returns DM Events for a DM Conversation """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_dm_conversations_with_participant_id_dm_events(
    participant_id: UserId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken32] = None,
    event_types: Optional[EventTypes] = [
        'MessageCreate',
        'ParticipantsLeave',
        'ParticipantsJoin',
    ],
    dm_event_fields: Optional[DmEventFields] = Query(None, alias='dm_event.fields'),
    expansions: Optional[Expansions1] = None,
    media_fields: Optional[MediaFields] = Query(None, alias='media.fields'),
    user_fields: Optional[UserFields] = Query(None, alias='user.fields'),
    tweet_fields: Optional[TweetFields] = Query(None, alias='tweet.fields'),
):
    """
    Get DM Events for a DM Conversation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/dm_conversations/with/{participant_id}/messages',
    description=""" Creates a new message for a DM Conversation with a participant user by ID """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dm_conversation_with_user_event_id_create(
    participant_id: UserId, body: CreateMessageRequest = None
):
    """
    Send a new message to a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/dm_conversations/{dm_conversation_id}/messages',
    description=""" Creates a new message for a DM Conversation specified by DM Conversation ID """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dm_conversation_by_id_event_id_create(
    dm_conversation_id: str, body: CreateMessageRequest = None
):
    """
    Send a new message to a DM Conversation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/dm_conversations/{id}/dm_events',
    description=""" Returns DM Events for a DM Conversation """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_dm_conversations_id_dm_events(
    id: DmConversationId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken32] = None,
    event_types: Optional[EventTypes1] = [
        'MessageCreate',
        'ParticipantsLeave',
        'ParticipantsJoin',
    ],
    dm_event_fields: Optional[DmEventFields1] = Query(None, alias='dm_event.fields'),
    expansions: Optional[Expansions2] = None,
    media_fields: Optional[MediaFields1] = Query(None, alias='media.fields'),
    user_fields: Optional[UserFields1] = Query(None, alias='user.fields'),
    tweet_fields: Optional[TweetFields1] = Query(None, alias='tweet.fields'),
):
    """
    Get DM Events for a DM Conversation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/dm_events',
    description=""" Returns recent DM Events across DM conversations """,
    tags=['direct_message_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_dm_events(
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken32] = None,
    event_types: Optional[EventTypes2] = [
        'MessageCreate',
        'ParticipantsLeave',
        'ParticipantsJoin',
    ],
    dm_event_fields: Optional[DmEventFields2] = Query(None, alias='dm_event.fields'),
    expansions: Optional[Expansions3] = None,
    media_fields: Optional[MediaFields2] = Query(None, alias='media.fields'),
    user_fields: Optional[UserFields2] = Query(None, alias='user.fields'),
    tweet_fields: Optional[TweetFields2] = Query(None, alias='tweet.fields'),
):
    """
    Get recent DM Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/lists',
    description=""" Creates a new List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_id_create(body: ListCreateRequest = None):
    """
    Create List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/lists/{id}',
    description=""" Delete a List that you own. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_id_delete(id: ListId):
    """
    Delete List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/lists/{id}',
    description=""" Returns a List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_id_get(
    id: ListId,
    list_fields: Optional[ListFields] = Query(None, alias='list.fields'),
    expansions: Optional[Expansions4] = None,
    user_fields: Optional[UserFields3] = Query(None, alias='user.fields'),
):
    """
    List lookup by List ID.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/2/lists/{id}',
    description=""" Update a List that you own. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_id_update(id: ListId, body: ListUpdateRequest = None):
    """
    Update List.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/lists/{id}/followers',
    description=""" Returns a list of Users that follow a List by the provided List ID """,
    tags=['list_operations', 'user_followed_lists_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_get_followers(
    id: ListId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    user_fields: Optional[UserFields4] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions5] = None,
    tweet_fields: Optional[TweetFields3] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that follow a List by the provided List ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/lists/{id}/members',
    description=""" Returns a list of Users that are members of a List by the provided List ID. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_get_members(
    id: ListId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    user_fields: Optional[UserFields5] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions6] = None,
    tweet_fields: Optional[TweetFields4] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that are members of a List by the provided List ID.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/lists/{id}/members',
    description=""" Causes a User to become a member of a List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_add_member(id: ListId, body: ListAddUserRequest = None):
    """
    Add a List member
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/lists/{id}/members/{user_id}',
    description=""" Causes a User to be removed from the members of a List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_remove_member(id: ListId, user_id: UserId = ...):
    """
    Remove a List member
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/lists/{id}/tweets',
    description=""" Returns a list of Tweets associated with the provided List ID. """,
    tags=['list_operations', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def lists_id_tweets(
    id: ListId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken36] = None,
    tweet_fields: Optional[TweetFields5] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions7] = None,
    media_fields: Optional[MediaFields3] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields6] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields] = Query(None, alias='place.fields'),
):
    """
    List Tweets timeline by List ID.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/openapi.json',
    description=""" Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md) """,
    tags=['compliance_job_management'],
)
def get_open_api_spec():
    """
    Returns the OpenAPI Specification document.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces',
    description=""" Returns a variety of information about the Spaces specified by the requested IDs """,
    tags=['space_search_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_spaces_by_ids(
    ids: Ids,
    space_fields: Optional[SpaceFields] = Query(None, alias='space.fields'),
    expansions: Optional[Expansions8] = None,
    user_fields: Optional[UserFields7] = Query(None, alias='user.fields'),
    topic_fields: Optional[TopicFields] = Query(None, alias='topic.fields'),
):
    """
    Space lookup up Space IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces/by/creator_ids',
    description=""" Returns a variety of information about the Spaces created by the provided User IDs """,
    tags=['space_search_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_spaces_by_creator_ids(
    user_ids: UserIds,
    space_fields: Optional[SpaceFields1] = Query(None, alias='space.fields'),
    expansions: Optional[Expansions9] = None,
    user_fields: Optional[UserFields8] = Query(None, alias='user.fields'),
    topic_fields: Optional[TopicFields1] = Query(None, alias='topic.fields'),
):
    """
    Space lookup by their creators
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces/search',
    description=""" Returns Spaces that match the provided query. """,
    tags=['space_search_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def search_spaces(
    query: constr(min_length=1, max_length=2048),
    state: Optional[State1] = 'all',
    max_results: Optional[conint(ge=1, le=100)] = 100,
    space_fields: Optional[SpaceFields2] = Query(None, alias='space.fields'),
    expansions: Optional[Expansions10] = None,
    user_fields: Optional[UserFields9] = Query(None, alias='user.fields'),
    topic_fields: Optional[TopicFields2] = Query(None, alias='topic.fields'),
):
    """
    Search for Spaces
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces/{id}',
    description=""" Returns a variety of information about the Space specified by the requested ID """,
    tags=['space_search_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_space_by_id(
    id: constr(pattern=r'^[a-zA-Z0-9]{1,13}$'),
    space_fields: Optional[SpaceFields3] = Query(None, alias='space.fields'),
    expansions: Optional[Expansions11] = None,
    user_fields: Optional[UserFields10] = Query(None, alias='user.fields'),
    topic_fields: Optional[TopicFields3] = Query(None, alias='topic.fields'),
):
    """
    Space lookup by Space ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces/{id}/buyers',
    description=""" Retrieves the list of Users who purchased a ticket to the given space """,
    tags=['space_search_operations', 'user_profile_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def space_buyers(
    id: constr(pattern=r'^[a-zA-Z0-9]{1,13}$'),
    pagination_token: Optional[PaginationToken32] = None,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    user_fields: Optional[UserFields11] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions12] = None,
    tweet_fields: Optional[TweetFields6] = Query(None, alias='tweet.fields'),
):
    """
    Retrieve the list of Users who purchased a ticket to the given space
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/spaces/{id}/tweets',
    description=""" Retrieves Tweets shared in the specified Space. """,
    tags=['space_search_operations', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def space_tweets(
    id: constr(pattern=r'^[a-zA-Z0-9]{1,13}$'),
    max_results: Optional[conint(ge=1, le=100)] = 100,
    tweet_fields: Optional[TweetFields7] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions13] = None,
    media_fields: Optional[MediaFields4] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields1] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields12] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields1] = Query(None, alias='place.fields'),
):
    """
    Retrieve Tweets from a Space.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets',
    description=""" Returns a variety of information about the Tweet specified by the requested ID. """,
    tags=['tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_tweets_by_id(
    ids: Ids1,
    tweet_fields: Optional[TweetFields8] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions14] = None,
    media_fields: Optional[MediaFields5] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields2] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields13] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields2] = Query(None, alias='place.fields'),
):
    """
    Tweet lookup by Tweet IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/tweets',
    description=""" Causes the User to create a Tweet under the authorized account. """,
    tags=['tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tweet(body: TweetCreateRequest):
    """
    Creation of a Tweet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/compliance/stream',
    description=""" Streams 100% of compliance data for Tweets """,
    tags=['compliance_job_management', 'tweet_operations', 'real_time_tweet_streaming'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_tweets_compliance_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    partition: conint(ge=1, le=4) = ...,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
):
    """
    Tweets Compliance stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/counts/all',
    description=""" Returns Tweet Counts that match a search query. """,
    tags=['tweet_count_statistics', 'tweet_archive_search'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def tweet_counts_full_archive_search(
    query: constr(min_length=1, max_length=4096),
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    next_token: Optional[PaginationToken36] = None,
    pagination_token: Optional[PaginationToken36] = None,
    granularity: Optional[Granularity] = 'hour',
    search_count_fields: Optional[SearchCountFields] = Query(
        None, alias='search_count.fields'
    ),
):
    """
    Full archive search counts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/counts/recent',
    description=""" Returns Tweet Counts from the last 7 days that match a search query. """,
    tags=['tweet_count_statistics', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def tweet_counts_recent_search(
    query: constr(min_length=1, max_length=4096),
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    next_token: Optional[PaginationToken36] = None,
    pagination_token: Optional[PaginationToken36] = None,
    granularity: Optional[Granularity] = 'hour',
    search_count_fields: Optional[SearchCountFields1] = Query(
        None, alias='search_count.fields'
    ),
):
    """
    Recent search counts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/firehose/stream',
    description=""" Streams 100% of public Tweets. """,
    tags=['real_time_tweet_streaming', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_tweets_firehose_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    partition: conint(ge=1, le=20) = ...,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields9] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions15] = None,
    media_fields: Optional[MediaFields6] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields3] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields14] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields3] = Query(None, alias='place.fields'),
):
    """
    Firehose stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/label/stream',
    description=""" Streams 100% of labeling events applied to Tweets """,
    tags=['real_time_tweet_streaming', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_tweets_label_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
):
    """
    Tweets Label stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/sample/stream',
    description=""" Streams a deterministic 1% of public Tweets. """,
    tags=['real_time_tweet_streaming', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sample_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    tweet_fields: Optional[TweetFields10] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions16] = None,
    media_fields: Optional[MediaFields7] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields4] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields15] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields4] = Query(None, alias='place.fields'),
):
    """
    Sample stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/sample10/stream',
    description=""" Streams a deterministic 10% of public Tweets. """,
    tags=['real_time_tweet_streaming', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_tweets_sample10_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    partition: conint(ge=1, le=2) = ...,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields11] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions17] = None,
    media_fields: Optional[MediaFields8] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields5] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields16] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields5] = Query(None, alias='place.fields'),
):
    """
    Sample 10% stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/search/all',
    description=""" Returns Tweets that match a search query. """,
    tags=['tweet_archive_search', 'tweet_operations', 'tweet_count_statistics'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def tweets_fullarchive_search(
    query: constr(min_length=1, max_length=4096),
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    max_results: Optional[conint(ge=10, le=500)] = 10,
    next_token: Optional[PaginationToken36] = None,
    pagination_token: Optional[PaginationToken36] = None,
    sort_order: Optional[SortOrder] = None,
    tweet_fields: Optional[TweetFields12] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions18] = None,
    media_fields: Optional[MediaFields9] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields6] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields17] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields6] = Query(None, alias='place.fields'),
):
    """
    Full-archive search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/search/recent',
    description=""" Returns Tweets from the last 7 days that match a search query. """,
    tags=['tweet_archive_search', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tweets_recent_search(
    query: constr(min_length=1, max_length=4096),
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    max_results: Optional[conint(ge=10, le=100)] = 10,
    next_token: Optional[PaginationToken36] = None,
    pagination_token: Optional[PaginationToken36] = None,
    sort_order: Optional[SortOrder] = None,
    tweet_fields: Optional[TweetFields13] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions19] = None,
    media_fields: Optional[MediaFields10] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields7] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields18] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields7] = Query(None, alias='place.fields'),
):
    """
    Recent search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/search/stream',
    description=""" Streams Tweets matching the stream's active rule set. """,
    tags=['real_time_tweet_streaming', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def search_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields14] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions20] = None,
    media_fields: Optional[MediaFields11] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields8] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields19] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields8] = Query(None, alias='place.fields'),
):
    """
    Filtered stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/search/stream/rules',
    description=""" Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids. """,
    tags=['tweet_archive_search'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_rules(
    ids: Optional[Ids2] = None,
    max_results: Optional[conint(ge=1, le=1000)] = 1000,
    pagination_token: Optional[constr(min_length=16, max_length=16)] = None,
):
    """
    Rules lookup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/tweets/search/stream/rules',
    description=""" Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values. """,
    tags=['user_owned_list_management', 'list_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def add_or_delete_rules(
    dry_run: Optional[bool] = None, body: AddOrDeleteRulesRequest = ...
):
    """
    Add/Delete rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/tweets/{id}',
    description=""" Delete specified Tweet (in the path) by ID. """,
    tags=['tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tweet_by_id(id: TweetId):
    """
    Tweet delete by Tweet ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/{id}',
    description=""" Returns a variety of information about the Tweet specified by the requested ID. """,
    tags=['tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_tweet_by_id(
    id: TweetId,
    tweet_fields: Optional[TweetFields15] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions21] = None,
    media_fields: Optional[MediaFields12] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields9] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields20] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields9] = Query(None, alias='place.fields'),
):
    """
    Tweet lookup by Tweet ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/{id}/liking_users',
    description=""" Returns a list of Users that have liked the provided Tweet ID """,
    tags=['tweet_interaction_operations', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tweets_id_liking_users(
    id: TweetId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken36] = None,
    user_fields: Optional[UserFields21] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions22] = None,
    tweet_fields: Optional[TweetFields16] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that have liked the provided Tweet ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/{id}/quote_tweets',
    description=""" Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID. """,
    tags=['tweet_operations', 'tweet_interaction_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_tweets_that_quote_a_tweet(
    id: TweetId,
    max_results: Optional[conint(ge=10, le=100)] = 10,
    pagination_token: Optional[PaginationToken36] = None,
    exclude: Optional[Exclude] = None,
    tweet_fields: Optional[TweetFields17] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions23] = None,
    media_fields: Optional[MediaFields13] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields10] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields22] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields10] = Query(None, alias='place.fields'),
):
    """
    Retrieve Tweets that quote a Tweet.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/tweets/{id}/retweeted_by',
    description=""" Returns a list of Users that have retweeted the provided Tweet ID """,
    tags=['tweet_interaction_operations', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tweets_id_retweeting_users(
    id: TweetId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationToken36] = None,
    user_fields: Optional[UserFields23] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions24] = None,
    tweet_fields: Optional[TweetFields18] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that have retweeted the provided Tweet ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/2/tweets/{tweet_id}/hidden',
    description=""" Hides or unhides a reply to an owned conversation. """,
    tags=['tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def hide_reply_by_id(tweet_id: TweetId, body: TweetHideRequest = None):
    """
    Hide replies
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users',
    description=""" This endpoint returns information about Users. Specify Users by their ID. """,
    tags=['user_profile_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_users_by_id(
    ids: Ids3,
    user_fields: Optional[UserFields24] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions25] = None,
    tweet_fields: Optional[TweetFields19] = Query(None, alias='tweet.fields'),
):
    """
    User lookup by IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/by',
    description=""" This endpoint returns information about Users. Specify Users by their username. """,
    tags=['user_profile_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_users_by_username(
    usernames: Usernames,
    user_fields: Optional[UserFields25] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions26] = None,
    tweet_fields: Optional[TweetFields20] = Query(None, alias='tweet.fields'),
):
    """
    User lookup by usernames
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/by/username/{username}',
    description=""" This endpoint returns information about a User. Specify User by username. """,
    tags=['user_profile_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_user_by_username(
    username: constr(pattern=r'^[A-Za-z0-9_]{1,15}$'),
    user_fields: Optional[UserFields26] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions27] = None,
    tweet_fields: Optional[TweetFields21] = Query(None, alias='tweet.fields'),
):
    """
    User lookup by username
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/compliance/stream',
    description=""" Streams 100% of compliance data for Users """,
    tags=['compliance_job_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_users_compliance_stream(
    backfill_minutes: Optional[conint(ge=0, le=5)] = None,
    partition: conint(ge=1, le=4) = ...,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
):
    """
    Users Compliance stream
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/me',
    description=""" This endpoint returns information about the requesting User. """,
    tags=['user_profile_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_my_user(
    user_fields: Optional[UserFields27] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions28] = None,
    tweet_fields: Optional[TweetFields22] = Query(None, alias='tweet.fields'),
):
    """
    User lookup me
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}',
    description=""" This endpoint returns information about a User. Specify User by ID. """,
    tags=['user_profile_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def find_user_by_id(
    id: UserId,
    user_fields: Optional[UserFields28] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions29] = None,
    tweet_fields: Optional[TweetFields23] = Query(None, alias='tweet.fields'),
):
    """
    User lookup by ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/blocking',
    description=""" Returns a list of Users that are blocked by the provided User ID """,
    tags=['user_block_and_mute_management', 'user_profile_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_blocking(
    id: UserIdMatchesAuthenticatedUser,
    max_results: Optional[conint(ge=1, le=1000)] = None,
    pagination_token: Optional[PaginationToken32] = None,
    user_fields: Optional[UserFields29] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions30] = None,
    tweet_fields: Optional[TweetFields24] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that are blocked by provided User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/blocking',
    description=""" Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request """,
    tags=['user_block_and_mute_management', 'user_profile_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_block(id: UserIdMatchesAuthenticatedUser, body: BlockUserRequest = ...):
    """
    Block User by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/bookmarks',
    description=""" Returns Tweet objects that have been bookmarked by the requesting User """,
    tags=['bookmark_management', 'user_profile_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users_id_bookmarks(
    id: UserIdMatchesAuthenticatedUser,
    max_results: Optional[conint(ge=1, le=100)] = None,
    pagination_token: Optional[PaginationToken36] = None,
    tweet_fields: Optional[TweetFields25] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions31] = None,
    media_fields: Optional[MediaFields14] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields11] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields30] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields11] = Query(None, alias='place.fields'),
):
    """
    Bookmarks by User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/bookmarks',
    description=""" Adds a Tweet (ID in the body) to the requesting User's (in the path) bookmarks """,
    tags=['bookmark_management', 'tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_users_id_bookmarks(
    id: UserIdMatchesAuthenticatedUser, body: BookmarkAddRequest = ...
):
    """
    Add Tweet to Bookmarks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{id}/bookmarks/{tweet_id}',
    description=""" Removes a Tweet from the requesting User's bookmarked Tweets. """,
    tags=['bookmark_management', 'tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_bookmarks_delete(
    id: UserIdMatchesAuthenticatedUser, tweet_id: TweetId = ...
):
    """
    Remove a bookmarked Tweet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/followed_lists',
    description=""" Returns a User's followed Lists. """,
    tags=['user_followed_lists_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def user_followed_lists(
    id: UserId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    list_fields: Optional[ListFields1] = Query(None, alias='list.fields'),
    expansions: Optional[Expansions32] = None,
    user_fields: Optional[UserFields31] = Query(None, alias='user.fields'),
):
    """
    Get User's Followed Lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/followed_lists',
    description=""" Causes a User to follow a List. """,
    tags=['list_operations', 'user_followed_lists_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_follow(
    id: UserIdMatchesAuthenticatedUser, body: ListFollowedRequest = None
):
    """
    Follow a List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{id}/followed_lists/{list_id}',
    description=""" Causes a User to unfollow a List. """,
    tags=['user_followed_lists_management', 'list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_unfollow(id: UserIdMatchesAuthenticatedUser, list_id: ListId = ...):
    """
    Unfollow a List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/followers',
    description=""" Returns a list of Users who are followers of the specified User ID. """,
    tags=['user_profile_operations', 'user_following_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_followers(
    id: UserId,
    max_results: Optional[conint(ge=1, le=1000)] = None,
    pagination_token: Optional[PaginationToken32] = None,
    user_fields: Optional[UserFields32] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions33] = None,
    tweet_fields: Optional[TweetFields26] = Query(None, alias='tweet.fields'),
):
    """
    Followers by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/following',
    description=""" Returns a list of Users that are being followed by the provided User ID """,
    tags=['user_profile_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_following(
    id: UserId,
    max_results: Optional[conint(ge=1, le=1000)] = None,
    pagination_token: Optional[PaginationToken32] = None,
    user_fields: Optional[UserFields33] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions34] = None,
    tweet_fields: Optional[TweetFields27] = Query(None, alias='tweet.fields'),
):
    """
    Following by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/following',
    description=""" Causes the User(in the path) to follow, or request to follow for protected Users, the target User. The User(in the path) must match the User context authorizing the request """,
    tags=['user_following_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_follow(
    id: UserIdMatchesAuthenticatedUser, body: UsersFollowingCreateRequest = None
):
    """
    Follow User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/liked_tweets',
    description=""" Returns a list of Tweets liked by the provided User ID """,
    tags=[
        'tweet_operations',
        'tweet_interaction_operations',
        'user_profile_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_liked_tweets(
    id: UserId,
    max_results: Optional[conint(ge=5, le=100)] = None,
    pagination_token: Optional[PaginationToken36] = None,
    tweet_fields: Optional[TweetFields28] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions35] = None,
    media_fields: Optional[MediaFields15] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields12] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields34] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields12] = Query(None, alias='place.fields'),
):
    """
    Returns Tweet objects liked by the provided User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/likes',
    description=""" Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request. """,
    tags=['tweet_interaction_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_like(
    id: UserIdMatchesAuthenticatedUser, body: UsersLikesCreateRequest = None
):
    """
    Causes the User (in the path) to like the specified Tweet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{id}/likes/{tweet_id}',
    description=""" Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request """,
    tags=['tweet_operations', 'tweet_interaction_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_unlike(id: UserIdMatchesAuthenticatedUser, tweet_id: TweetId = ...):
    """
    Causes the User (in the path) to unlike the specified Tweet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/list_memberships',
    description=""" Get a User's List Memberships. """,
    tags=[
        'list_operations',
        'user_followed_lists_management',
        'user_owned_list_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_list_memberships(
    id: UserId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    list_fields: Optional[ListFields2] = Query(None, alias='list.fields'),
    expansions: Optional[Expansions36] = None,
    user_fields: Optional[UserFields35] = Query(None, alias='user.fields'),
):
    """
    Get a User's List Memberships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/mentions',
    description=""" Returns Tweet objects that mention username associated to the provided User ID """,
    tags=['user_timeline_access', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_mentions(
    id: UserId,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    max_results: Optional[conint(ge=5, le=100)] = None,
    pagination_token: Optional[PaginationToken36] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields29] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions37] = None,
    media_fields: Optional[MediaFields16] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields13] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields36] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields13] = Query(None, alias='place.fields'),
):
    """
    User mention timeline by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/muting',
    description=""" Returns a list of Users that are muted by the provided User ID """,
    tags=['user_block_and_mute_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_muting(
    id: UserIdMatchesAuthenticatedUser,
    max_results: Optional[conint(ge=1, le=1000)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    user_fields: Optional[UserFields37] = Query(None, alias='user.fields'),
    expansions: Optional[Expansions38] = None,
    tweet_fields: Optional[TweetFields30] = Query(None, alias='tweet.fields'),
):
    """
    Returns User objects that are muted by the provided User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/muting',
    description=""" Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request. """,
    tags=['user_block_and_mute_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_mute(id: UserIdMatchesAuthenticatedUser, body: MuteUserRequest = None):
    """
    Mute User by User ID.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/owned_lists',
    description=""" Get a User's Owned Lists. """,
    tags=['user_owned_list_management', 'list_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_owned_lists(
    id: UserId,
    max_results: Optional[conint(ge=1, le=100)] = 100,
    pagination_token: Optional[PaginationTokenLong] = None,
    list_fields: Optional[ListFields3] = Query(None, alias='list.fields'),
    expansions: Optional[Expansions39] = None,
    user_fields: Optional[UserFields38] = Query(None, alias='user.fields'),
):
    """
    Get a User's Owned Lists.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/pinned_lists',
    description=""" Get a User's Pinned Lists. """,
    tags=['user_owned_list_management', 'user_followed_lists_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_pinned_lists(
    id: UserIdMatchesAuthenticatedUser,
    list_fields: Optional[ListFields4] = Query(None, alias='list.fields'),
    expansions: Optional[Expansions40] = None,
    user_fields: Optional[UserFields39] = Query(None, alias='user.fields'),
):
    """
    Get a User's Pinned Lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/pinned_lists',
    description=""" Causes a User to pin a List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_pin(id: UserIdMatchesAuthenticatedUser, body: ListPinnedRequest = ...):
    """
    Pin a List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{id}/pinned_lists/{list_id}',
    description=""" Causes a User to remove a pinned List. """,
    tags=['list_operations', 'user_owned_list_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_user_unpin(id: UserIdMatchesAuthenticatedUser, list_id: ListId = ...):
    """
    Unpin a List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2/users/{id}/retweets',
    description=""" Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request. """,
    tags=['tweet_interaction_operations', 'tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_retweets(
    id: UserIdMatchesAuthenticatedUser, body: UsersRetweetsCreateRequest = None
):
    """
    Causes the User (in the path) to retweet the specified Tweet.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{id}/retweets/{source_tweet_id}',
    description=""" Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request """,
    tags=['tweet_interaction_operations', 'tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_unretweets(
    id: UserIdMatchesAuthenticatedUser, source_tweet_id: TweetId = ...
):
    """
    Causes the User (in the path) to unretweet the specified Tweet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/timelines/reverse_chronological',
    description=""" Returns Tweet objects that appears in the provided User ID's home timeline """,
    tags=['user_timeline_access', 'tweet_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_timeline(
    id: UserIdMatchesAuthenticatedUser,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    max_results: Optional[conint(ge=1, le=100)] = None,
    pagination_token: Optional[PaginationToken36] = None,
    exclude: Optional[Exclude1] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields31] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions41] = None,
    media_fields: Optional[MediaFields17] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields14] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields40] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields14] = Query(None, alias='place.fields'),
):
    """
    User home timeline by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2/users/{id}/tweets',
    description=""" Returns a list of Tweets authored by the provided User ID """,
    tags=['user_timeline_access', 'tweet_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_tweets(
    id: UserId,
    since_id: Optional[TweetId] = None,
    until_id: Optional[TweetId] = None,
    max_results: Optional[conint(ge=5, le=100)] = None,
    pagination_token: Optional[PaginationToken36] = None,
    exclude: Optional[Exclude2] = None,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    tweet_fields: Optional[TweetFields32] = Query(None, alias='tweet.fields'),
    expansions: Optional[Expansions42] = None,
    media_fields: Optional[MediaFields18] = Query(None, alias='media.fields'),
    poll_fields: Optional[PollFields15] = Query(None, alias='poll.fields'),
    user_fields: Optional[UserFields41] = Query(None, alias='user.fields'),
    place_fields: Optional[PlaceFields15] = Query(None, alias='place.fields'),
):
    """
    User Tweets timeline by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{source_user_id}/blocking/{target_user_id}',
    description=""" Causes the source User to unblock the target User. The source User must match the User context authorizing the request """,
    tags=['user_block_and_mute_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_unblock(
    source_user_id: UserIdMatchesAuthenticatedUser, target_user_id: UserId = ...
):
    """
    Unblock User by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{source_user_id}/following/{target_user_id}',
    description=""" Causes the source User to unfollow the target User. The source User must match the User context authorizing the request """,
    tags=['user_following_operations', 'user_block_and_mute_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_unfollow(
    source_user_id: UserIdMatchesAuthenticatedUser, target_user_id: UserId = ...
):
    """
    Unfollow User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2/users/{source_user_id}/muting/{target_user_id}',
    description=""" Causes the source User to unmute the target User. The source User must match the User context authorizing the request """,
    tags=['user_block_and_mute_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def users_id_unmute(
    source_user_id: UserIdMatchesAuthenticatedUser, target_user_id: UserId = ...
):
    """
    Unmute User by User ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
